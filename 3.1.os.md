# import os
## const
>		// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.

	O_RDONLY int = syscall.O_RDONLY // open the file read-only.
	O_WRONLY int = syscall.O_WRONLY // open the file write-only.
	O_RDWR   int = syscall.O_RDWR   // open the file read-write.

>		// The remaining values may be or'ed in to control behavior.

	O_APPEND int = syscall.O_APPEND // append data to the file when writing.
	O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
	O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
	O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.
	O_TRUNC  int = syscall.O_TRUNC  // if possible, truncate file when opened.

>		// Seek whence values.
>		//
>		// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.
>	这三个值已经被废弃, 使用 io.SeekStart, io.SeekCurrent, io.SeekEnd 代替

	SEEK_SET int = 0 // seek relative to the origin of the file
	SEEK_CUR int = 1 // seek relative to the current offset
	SEEK_END int = 2 // seek relative to the end
>[io.SeekStart](2.1.io.md#const) [io.SeekCurrent](2.1.io.md#const) [io.SeekEnd](2.1.io.md#const)

### const FileMode
>		// The single letters are the abbreviations
>		// used by the String method's formatting.

	ModeDir        FileMode = 1 << (32 - 1 - iota) // d: is a directory
	ModeAppend                                     // a: append-only
	ModeExclusive                                  // l: exclusive use
	ModeTemporary                                  // T: temporary file; Plan 9 only
	ModeSymlink                                    // L: symbolic link
	ModeDevice                                     // D: device file
	ModeNamedPipe                                  // p: named pipe (FIFO)
	ModeSocket                                     // S: Unix domain socket
	ModeSetuid                                     // u: setuid
	ModeSetgid                                     // g: setgid
	ModeCharDevice                                 // c: Unix character device, when ModeDevice is set
	ModeSticky                                     // t: sticky

>		// Mask for the type bits. For regular files, none will be set.

	ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice

	ModePerm FileMode = 0777 // Unix permission bits

## var
>	标准输入

	Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")

>	标准输出

	Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")

>	标准错误

	Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")


## interface
### FileInfo
>		// A FileInfo describes a file and is returned by Stat and Lstat.

	type FileInfo interface {
		Name() string       // base name of the file
		Size() int64        // length in bytes for regular files; system-dependent for others
		Mode() FileMode     // file mode bits
		ModTime() time.Time // modification time
		IsDir() bool        // abbreviation for Mode().IsDir()
		Sys() interface{}   // underlying data source (can return nil)
	}

## struct
### LinkError
>		// LinkError records an error during a link or symlink or rename
>		// system call and the paths that caused it.

	type LinkError struct {
		Op  string
		Old string
		New string
		Err error
	}

	func (e *LinkError) Error() string

### File
>		// File represents an open file descriptor.

	type File struct {
		*file // os specific
	}

	func (f *File) Name() string

	func (f *File) Read(b []byte) (int, error)

	func (f *File) ReadAt(b []byte, off int64) (int, error)

	func (f *File) Write(b []byte) (int, error)

	func (f *File) WriteAt(b []byte, off int64) (int, error)

	func (f *File) Seek(offset int64, whence int) (int64, error)
>[whence](2.1.io.md#const)

	func (f *File) WriteString(s string) (int, error)

	func (f *File) Chmod(mode FileMode) error

	func (f *File) SetDealline(t time.Time) error

	func (f *File) SetReadDealline(t time.Time) error

	func (f *File) SetWriteDeadline(t time.Time) error

	func (f *File) Readdir(n int) ([]FileInfo, error)

	func (f *File) Readdirnames(n int) (names []string, err error)

### FileMode
	type FileMode uint32
>[const FileMode](#const-filemode)

	func (m FileMode) IsDir() bool

	func (m FileMode) IsRegular() bool

	func (m FileMode) Perm() FileMode

### fileStat
>[FileInfo](#fileinfo)

	func (fs *fileStat) Name() string //返回文件名称
	func (fs *fileStat) IsDir() bool //返回是否是文件夹
	func (fs *fileStat) Size() int64 //返回文件大小 字节
	func (fs *fileStat) Mode() FileMode //返回文件权限
	func (fs *fileStat) ModTime() time.Time //返回文件上次修改时间
	func (fs *fileStat) Sys() interface{} //返回文件系统信息

## func
### Hostname
	func Hostname() (string, error)
>		//返回主机名

### Stat
	func Stat(name string) (FileInfo, error)
>[fileStat](#filestat)
>		fileInfo, err := os.Stat("filename.txt")

### Lstat
	func Lstat(name string) (FileInfo, error)
>[fileStat](#filestat)

### SameFile
	func SameFile(fi1, fi2 FileInfo) bool
>[FileInfo](#fileinfo)
>		f1 := os.Stat("f1.txt")
>		f2 := os.Stat("f2.txt")
>		isSameFile, err := os.SameFile(f1, f2) // false nil
>		f2 := os.Stat("f1.txt")
>		isSameFile, err := os.SameFile(f1, f2) // true nil

### Exit
	func Exit(code int)
>		os.Exit(1)
>			//直接退出程序，方法内退出不会执行defer

### Remove
	func Remove(name string) error
>		err := os.Remove("filename")
>			//当filename是一个文件时，直接删除；
>			//当filename是一个文件夹时，如果文件夹下有文件，会提示非空文件夹，删除失败；如果是一个空文件夹，直接删除

### RemoveAll
	func RemoveAll(path string) error
>		err := os.RemoveAll("dirname")
>			//类似 rm -rf dirname

### Getwd
	func Getwd() (dir string, err error)
>		dir, err := os.Getwd()
>			//获取当前程序执行的目录  pwd

### Mkdir
	func Mkdir(name string, perm FileMode) error
>		err := os.Mkdir("./abc", 0666)
>			//创建目录 mkdir，但是无法创建多级目录(没有 mkdir -p 功能)

### MkdirAll
	func MkdirAll(path string, perm FileMode) error
>		err := os.MkdirAll("./abc/def", 0666)
>			//可以创建多级目录，相当于 mkdir -p

### Chdir
	func Chdir(dir string) error
>		err := os.Chdir("./abc")
>			//修改当前程序执行的路径
>		f, err := os.Create("ab.txt") //创建文件 abc/ab.txt
>		defer f.Close()
>		if err == nil {
>			f.WriteString("hello world !")
>		}

### Open
	func Open(name string) (*File, error)
>		f, err := os.Open("filename.txt")
>			//如果文件存在，则返回 *File && error == nil, 如果文件不存在 error != nil

### Create
	func Create(name string) (*File, error)
>		f, err := os.Create("filename.txt")
>			//如果文件不存在，则创建文件；如果文件存在，再调用该方法，会清空文件之前的内容

### OpenFile
	func OpenFile(name string, flag int, perm FileMode) (*File, error)
>		f, err := os.OpenFile("filename.txt", os.O_CREATE|os.O_RDONLY|os.O_WRONLY|os.O_APPEND, 0644)
>	[flag](#const) [perm](#const-filemode)

### Rename
	func Rename(oldpath, newpath string) error
>		err := os.Rename("oldfile.txt", "newfile.txt")
>			//类似 mv oldpaht newpath, 成功 err == nil, 失败 err != nil

### TempDir
	func TempDir() string
>		tmpDir := os.TempDir()
>			//返回临时文件目录

### Chmod
	func Chmod(name string, mode FileMode) error
>		err := os.Chmod("filename.txt", 0777)
>			//修改文件权限

### Executable
	func Executable() (string, error)
>executable 暂未用到

### Getuid
	func Getuid() int
>proc 暂未用到

### Geteuid
	func Geteuid() int
>proc 暂未用到

### Getgid
	func Getgid() int
>proc 暂未用到

### Getegid
	func Getegid() int
>proc 暂未用到

### Getgroups
	func Getgroups() ([]int, error)
>proc 暂未用到
